


```cpp


还有虚函数的基本知识：
只要基类函数是virtual的，派生类相应函数不管有没有virtual修饰都是vritual的


如果要用多态的特性，基类的虚函数必须要虚的，否则析构对象不完整。
不用多态的特性，则不需要虚函数，毕竟虚函数多了个查表的过程，影响些效率。
只要基类某个函数是虚的，所有继承这个基类的函数（包括继承的继承）都是虚的，不写virtual，系统默认也是virtual的，一日为虚，终身为虚。



 析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。





class B {
public:
    virtual ~B() {}
    int data1;
};

class D : public B {
public:
    virtual ~D() {}
    int data2;
};

int main() {
    B *pB = new D;
    delete pB;
    return 0;
}


D被实例化之后在内存里大概是这个样子：

| - vtbl - | - data1 - | - data2 - |

只看前两个部分就是基类B，即 vtbl + data1。
三部分都看就是子类D，即 vtbl + data1 + data2。
也就是说内存中只有一个对象，不是既有基类的实例又有子类实例，所谓的子类指针转基类指针只不过是把视野缩小而已。
虚函数和非虚函数的区别是就是查不查表而已，由于每个实例一张虚表（单继承），子类实现了基类的虚函数会将虚表中的函数地址改成自己（子类）的函数地址。而虚函数的调用，即查表的方法，就是按照所调用函数在表中的索引去查，同一个函数，在表中的索引是相同的。非虚函数由于不需要查表，在编译的时候会直接将函数地址硬编码进去。

class B {
public:
    virtual void VFunc() {} /* 0x1 */
    void NVFunc() {}        /* 0x2 */
};
class D : public B {
public:
    virtual void VFunc() {} /* 0x3 */
    void NVFunc() {}        /* 0x4 */
};

int main() {
    B *pB = new D;
    pB->NVFunc();           /* call 0x2 */
    return 0;
}

D被实例化之后是这样（由于没有数据成员，所以只有一个虚表指针）：
| - vtbl - |
虚表中的内容是：
--------------------------------
0x3(D::VFunc的地址)
--------------------------------
因为NVFunc是非虚函数，不需要查表，pB->NVFunc指明了调用B::NVFunc，编译的时候直接将其地址0x2硬编码进去。
对于虚析构函数，是一个比较特殊的存在，子类的析构函数不会直接将虚表中基类的析构函数地址替换成自己的，而是会构造一个特殊的函数，依次调用子类，基类的析构函数（不好意思之前不小心写反了，构造函数的调用顺序是基类，子类，析构刚好相反，不然子类析构函数无法访问基类成员，因为已销毁），再将这个特殊的函数放入虚表。析构的时候，通过查表找到该函数当做自己的析构函数，假设析构函数的索引为0，则无论基类还是子类析构的时候都是调用this->vtbl[0]。

```