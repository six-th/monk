
namespace std {
  // 帮助类：
  template <class T, T v> struct integral_constant;
  template <bool B>
  using bool_constant = integral_constant<bool, B>;
  using true_type = bool_constant<true>;
  using false_type = bool_constant<false>;
 
  // 基础类型类别：
  template <class T> struct is_void;
  template <class T> struct is_null_pointer;
  template <class T> struct is_integral;
  template <class T> struct is_floating_point;
  template <class T> struct is_array;
  template <class T> struct is_pointer;
  template <class T> struct is_lvalue_reference;
  template <class T> struct is_rvalue_reference;
  template <class T> struct is_member_object_pointer;
  template <class T> struct is_member_function_pointer;
  template <class T> struct is_enum;
  template <class T> struct is_union;
  template <class T> struct is_class;
  template <class T> struct is_function;
 
  // 复合类型类别：
  template <class T> struct is_reference;
  template <class T> struct is_arithmetic;
  template <class T> struct is_fundamental;
  template <class T> struct is_object;
  template <class T> struct is_scalar;
  template <class T> struct is_compound;
  template <class T> struct is_member_pointer;
 
  // 类型属性：
  template <class T> struct is_const;
  template <class T> struct is_volatile;
  template <class T> struct is_trivial;
  template <class T> struct is_trivially_copyable;
  template <class T> struct is_standard_layout;
  template <class T> struct is_pod;
  template <class T> struct is_empty;
  template <class T> struct is_polymorphic;
  template <class T> struct is_abstract;
  template <class T> struct is_final;
  template <class T> struct is_aggregate;
  template <class T> struct is_signed;
  template <class T> struct is_unsigned;
  template <class T, class... Args> struct is_constructible;
  template <class T> struct is_default_constructible;
  template <class T> struct is_copy_constructible;
  template <class T> struct is_move_constructible;
  template <class T, class U> struct is_assignable;
  template <class T> struct is_copy_assignable;
  template <class T> struct is_move_assignable;
  template <class T, class U> struct is_swappable_with;
  template <class T> struct is_swappable;
  template <class T> struct is_destructible;
  template <class T, class... Args> struct is_trivially_constructible;
  template <class T> struct is_trivially_default_constructible;
  template <class T> struct is_trivially_copy_constructible;
  template <class T> struct is_trivially_move_constructible;
  template <class T, class U> struct is_trivially_assignable;
  template <class T> struct is_trivially_copy_assignable;
  template <class T> struct is_trivially_move_assignable;
  template <class T> struct is_trivially_destructible;
  template <class T, class... Args> struct is_nothrow_constructible;
  template <class T> struct is_nothrow_default_constructible;
  template <class T> struct is_nothrow_copy_constructible;
  template <class T> struct is_nothrow_move_constructible;
  template <class T, class U> struct is_nothrow_assignable;
  template <class T> struct is_nothrow_copy_assignable;
  template <class T> struct is_nothrow_move_assignable;
  template <class T, class U> struct is_nothrow_swappable_with;
  template <class T> struct is_nothrow_swappable;
  template <class T> struct is_nothrow_destructible;
  template <class T> struct has_virtual_destructor;
  template <class T> struct has_unique_object_representations;
 
  // 类型属性查询：
  template <class T> struct alignment_of;
  template <class T> struct rank;
  template <class T, unsigned I = 0> struct extent;
 
  // 类型关系：
  template <class T, class U> struct is_same;
  template <class Base, class Derived> struct is_base_of;
  template <class From, class To> struct is_convertible;
  template <class Fn, class... ArgTypes> struct is_invocable;
  template <class R, class Fn, class... ArgTypes> struct is_invocable_r;
  template <class Fn, class... ArgTypes> struct is_nothrow_invocable;
  template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;
 
  // const-volatile 修改：
  template <class T> struct remove_const;
  template <class T> struct remove_volatile;
  template <class T> struct remove_cv;
  template <class T> struct add_const;
  template <class T> struct add_volatile;
  template <class T> struct add_cv;
  template <class T>
  using remove_const_t = typename remove_const<T>::type;
  template <class T>
  using remove_volatile_t = typename remove_volatile<T>::type;
  template <class T>
  using remove_cv_t = typename remove_cv<T>::type;
  template <class T>
  using add_const_t = typename add_const<T>::type;
  template <class T>
  using add_volatile_t = typename add_volatile<T>::type;
  template <class T>
  using add_cv_t = typename add_cv<T>::type;
 
  // 引用修改：
  template <class T> struct remove_reference;
  template <class T> struct add_lvalue_reference;
  template <class T> struct add_rvalue_reference;
  template <class T>
  using remove_reference_t = typename remove_reference<T>::type;
  template <class T>
  using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
  template <class T>
  using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;
 
  // 符号修改：
  template <class T> struct make_signed;
  template <class T> struct make_unsigned;
  template <class T>
  using make_signed_t = typename make_signed<T>::type;
  template <class T>
  using make_unsigned_t = typename make_unsigned<T>::type;
 
  // 数组修改：
  template <class T> struct remove_extent;
  template <class T> struct remove_all_extents;
  template <class T>
  using remove_extent_t = typename remove_extent<T>::type;
  template <class T>
  using remove_all_extents_t = typename remove_all_extents<T>::type;
 
  // 指针修改：
  template <class T> struct remove_pointer;
  template <class T> struct add_pointer;
  template <class T>
  using remove_pointer_t = typename remove_pointer<T>::type;
  template <class T>
  using add_pointer_t = typename add_pointer<T>::type;
 
  // 其他变换：
  template <size_t Len,
  size_t Align = /*default-alignment*/ > 
  struct aligned_storage;
  template <size_t Len, class... Types> struct aligned_union;
  template <class T> struct decay;
  template <class T> struct remove_cvref;
  template <bool, class T = void> struct enable_if;
  template <bool, class T, class F> struct conditional;
  template <class... T> struct common_type;
  template <class T> struct underlying_type;
  template <class> class result_of; // 不定义
  template <class F, class... ArgTypes> class result_of<F(ArgTypes...)>;
  template <class F, class... ArgTypes> class invoke_result;
  template <size_t Len,
  size_t Align = /*default-alignment*/ > 
  using aligned_storage_t = typename aligned_storage<Len, Align>::type;
  template <size_t Len, class... Types>
  using aligned_union_t = typename aligned_union<Len, Types...>::type;
  template <class T>
  using decay_t = typename decay<T>::type;
  template <class T>
  using remove_cvref_t = typename remove_cvref<T>::type;
  template <bool b, class T = void>
  using enable_if_t = typename enable_if<b, T>::type;
  template <bool b, class T, class F>
  using conditional_t = typename conditional<b, T, F>::type;
  template <class... T>
  using common_type_t = typename common_type<T...>::type;
  template <class T>
  using underlying_type_t = typename underlying_type<T>::type;
  template <class T>
  using result_of_t = typename result_of<T>::type;
  template <class F, class... ArgTypes> 
  using invoke_result_t = typename invoke_result<F, ArgTypes...>::type;
  template <class...>
  using void_t = void;
 
  // 逻辑运算符特性：
  template<class... B> struct conjunction;
  template<class... B> struct disjunction;
  template<class B> struct negation;
 
  // 端序
  enum class endian {
    little = /*implementation-defined*/,
    big    = /*implementation-defined*/,
    native = /*implementation-defined*/
  };
 
  // 基础类型类别
  template <class T> inline constexpr bool is_void_v
  = is_void<T>::value;
  template <class T> inline constexpr bool is_null_pointer_v
  = is_null_pointer<T>::value;
  template <class T> inline constexpr bool is_integral_v
  = is_integral<T>::value;
  template <class T> inline constexpr bool is_floating_point_v
  = is_floating_point<T>::value;
  template <class T> inline constexpr bool is_array_v
  = is_array<T>::value;
  template <class T> inline constexpr bool is_pointer_v
  = is_pointer<T>::value;
  template <class T> inline constexpr bool is_lvalue_reference_v
  = is_lvalue_reference<T>::value;
  template <class T> inline constexpr bool is_rvalue_reference_v
  = is_rvalue_reference<T>::value;
  template <class T> inline constexpr bool is_member_object_pointer_v
  = is_member_object_pointer<T>::value;
  template <class T> inline constexpr bool is_member_function_pointer_v
  = is_member_function_pointer<T>::value;
  template <class T> inline constexpr bool is_enum_v
  = is_enum<T>::value;
  template <class T> inline constexpr bool is_union_v
  = is_union<T>::value;
  template <class T> inline constexpr bool is_class_v
  = is_class<T>::value;
  template <class T> inline constexpr bool is_function_v
  = is_function<T>::value;
 
  // 复合类型类别
  template <class T> inline constexpr bool is_reference_v
  = is_reference<T>::value;
  template <class T> inline constexpr bool is_arithmetic_v
  = is_arithmetic<T>::value;
  template <class T> inline constexpr bool is_fundamental_v
  = is_fundamental<T>::value;
  template <class T> inline constexpr bool is_object_v
  = is_object<T>::value;
  template <class T> inline constexpr bool is_scalar_v
  = is_scalar<T>::value;
  template <class T> inline constexpr bool is_compound_v
  = is_compound<T>::value;
  template <class T> inline constexpr bool is_member_pointer_v
  = is_member_pointer<T>::value;
 
  // 类型属性
  template <class T> inline constexpr bool is_const_v
  = is_const<T>::value;
  template <class T> inline constexpr bool is_volatile_v
  = is_volatile<T>::value;
  template <class T> inline constexpr bool is_trivial_v
  = is_trivial<T>::value;
  template <class T> inline constexpr bool is_trivially_copyable_v
  = is_trivially_copyable<T>::value;
  template <class T> inline constexpr bool is_standard_layout_v
  = is_standard_layout<T>::value;
  template <class T> inline constexpr bool is_pod_v
  = is_pod<T>::value;
  template <class T> inline constexpr bool is_empty_v
  = is_empty<T>::value;
  template <class T> inline constexpr bool is_polymorphic_v
  = is_polymorphic<T>::value;
  template <class T> inline constexpr bool is_abstract_v
  = is_abstract<T>::value;
  template <class T> inline constexpr bool is_final_v
  = is_final<T>::value;
  template <class T> inline constexpr bool is_aggregate_v
  = is_aggregate<T>::value;
  template <class T> inline constexpr bool is_signed_v
  = is_signed<T>::value;
  template <class T> inline constexpr bool is_unsigned_v
  = is_unsigned<T>::value;
  template <class T, class... Args> inline constexpr bool is_constructible_v
  = is_constructible<T, Args...>::value;
  template <class T> inline constexpr bool is_default_constructible_v
  = is_default_constructible<T>::value;
  template <class T> inline constexpr bool is_copy_constructible_v
  = is_copy_constructible<T>::value;
  template <class T> inline constexpr bool is_move_constructible_v
  = is_move_constructible<T>::value;
  template <class T, class U> inline constexpr bool is_assignable_v
  = is_assignable<T, U>::value;
  template <class T> inline constexpr bool is_copy_assignable_v
  = is_copy_assignable<T>::value;
  template <class T> inline constexpr bool is_move_assignable_v
  = is_move_assignable<T>::value;
  template <class T, class U> inline constexpr bool is_swappable_with_v
  = is_swappable_with<T, U>::value;
  template <class T> inline constexpr bool is_swappable_v
  = is_swappable<T>::value;
  template <class T> inline constexpr bool is_destructible_v
  = is_destructible<T>::value;
  template <class T, class... Args> inline constexpr bool is_trivially_constructible_v
  = is_trivially_constructible<T, Args...>::value;
  template <class T> inline constexpr bool is_trivially_default_constructible_v
  = is_trivially_default_constructible<T>::value;
  template <class T> inline constexpr bool is_trivially_copy_constructible_v
  = is_trivially_copy_constructible<T>::value;
  template <class T> inline constexpr bool is_trivially_move_constructible_v
  = is_trivially_move_constructible<T>::value;
  template <class T, class U> inline constexpr bool is_trivially_assignable_v
  = is_trivially_assignable<T, U>::value;
  template <class T> inline constexpr bool is_trivially_copy_assignable_v
  = is_trivially_copy_assignable<T>::value;
  template <class T> inline constexpr bool is_trivially_move_assignable_v
  = is_trivially_move_assignable<T>::value;
  template <class T> inline constexpr bool is_trivially_destructible_v
  = is_trivially_destructible<T>::value;
  template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v
  = is_nothrow_constructible<T, Args...>::value;
  template <class T> inline constexpr bool is_nothrow_default_constructible_v
  = is_nothrow_default_constructible<T>::value;
  template <class T> inline constexpr bool is_nothrow_copy_constructible_v
  = is_nothrow_copy_constructible<T>::value;
  template <class T> inline constexpr bool is_nothrow_move_constructible_v
  = is_nothrow_move_constructible<T>::value;
  template <class T, class U> inline constexpr bool is_nothrow_assignable_v
  = is_nothrow_assignable<T, U>::value;
  template <class T> inline constexpr bool is_nothrow_copy_assignable_v
  = is_nothrow_copy_assignable<T>::value;
  template <class T> inline constexpr bool is_nothrow_move_assignable_v
  = is_nothrow_move_assignable<T>::value;
  template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v
  = is_nothrow_swappable_with<T, U>::value;
  template <class T> inline constexpr bool is_nothrow_swappable_v
  = is_nothrow_swappable<T>::value;
  template <class T> inline constexpr bool is_nothrow_destructible_v
  = is_nothrow_destructible<T>::value;
  template <class T> inline constexpr bool has_virtual_destructor_v
  = has_virtual_destructor<T>::value;
  template <class T> inline constexpr bool has_unique_object_representations_v
  = has_unique_object_representations<T>::value;
 
  // 类型属性查询
  template <class T> inline constexpr size_t alignment_of_v
  = alignment_of<T>::value;
  template <class T> inline constexpr size_t rank_v
  = rank<T>::value;
  template <class T, unsigned I = 0> inline constexpr size_t extent_v
  = extent<T, I>::value;
 
  // 类型关系
  template <class T, class U> inline constexpr bool is_same_v
  = is_same<T, U>::value;
  template <class Base, class Derived> inline constexpr bool is_base_of_v
  = is_base_of<Base, Derived>::value;
  template <class From, class To> inline constexpr bool is_convertible_v
  = is_convertible<From, To>::value;
 
  template <class Fn, class... ArgTypes> 
  inline constexpr bool is_invocable_v
    = is_invocable<Fn, ArgTypes...>::value;
  template <class R, class Fn, class... ArgTypes>
  inline constexpr bool is_invocable_r_v
    = is_invocable_r<R, Fn, ArgTypes...>::value;
  template <class Fn, class... ArgTypes>
  inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<Fn, ArgTypes...>::value;
  template <class R, class Fn, class... ArgTypes>
  inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;
 
  // 逻辑运算符特性：
  template<class... B> inline constexpr bool conjunction_v = conjunction<B...>::value;
  template<class... B> inline constexpr bool disjunction_v = disjunction<B...>::value;
  template<class B> inline constexpr bool negation_v = negation<B>::value;
} // namespace std


namespace std {
  template <class T, T v>
  struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type = integral_constant<T, v>;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
  };
}