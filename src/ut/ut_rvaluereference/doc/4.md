
# 4.右值引用的使用方式

### 参与者
C++中, 一个类通常会与其上层和下层打交道, 若要最大化利用右值引用来提升性能,需要做如下工作:
![这里写图片描述](https://img-blog.csdn.net/20180524181139957?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



* [类访问者]: 在恰当的时机, vistor调用classA提供的接受右值引用参数的方法(可能是普通方法, 构造函数, 拷贝构造函数等);

* [类实现者]: 实现所有接受右值引用参数的方法;

* [下层类] : 下层类subClass实现所有接受右值引用参数的方法,供clasA在实现时调用(这时候,classA相当于vistor的角色了);


### 例1:类访问者
[类访问者]: 在恰当的时机, vistor调用实现者(ncMetadataObj)提供的接受右值引用参数的方法


##### 测试不同的访问方式带来的性能差异
```c++
//类实现者
class ncMetadataObj
{
public:
    void push_back(const ncNewCustomString& str)
    {
        _newCustomStr = str;
    }
    
    void push_back(ncNewCustomString&& str)
    {
        _newCustomStr = std::move(str);
    }
    
private:
    ncNewCustomString           _newCustomStr;
};

//类访问者
TEST(ut_metadataObj, push_back)
{
    //访问者不同的访问方式,调用的接口不同;
    ncMetadataObj obj;
    {
        ncAutoProfilePoint point(usedSecond);
        ncNewCustomString str("some string...");
        obj.push_back(str);
    }
    MK_PRINT_MSG("push_back--1 usedSecond = %.2f\n", usedSecond);
    
    {
        ncAutoProfilePoint point(usedSecond);
        ncNewCustomString str("some string...");
        obj.push_back(std::move(str));
    }
    MK_PRINT_MSG("push_back--2 usedSecond = %.2f\n", usedSecond);
    
    {
        ncAutoProfilePoint point(usedSecond);
        obj.push_back(ncNewCustomString("some string..."));
    }
    MK_PRINT_MSG("push_back--3 usedSecond = %.2f\n", usedSecond);
}

/*
源码路径:
ut_rvaluereference\usage\ut_metadataObj.cpp
*/
```

执行结果:
![这里写图片描述](https://img-blog.csdn.net/20180524181155477?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


备注:
访问者不同的访问方式,调用的接口不同, 关键点在于待访问类的具体实现


### 例2:类实现者
[类实现者]: 提供并实现所有接受右值引用参数的方法

```c++
//类实现者
class ncMetadataObj
{
public:
    ncMetadataObj(const ncOldCustomString& str);
    ncMetadataObj(ncOldCustomString&& str);
    
    ncMetadataObj(const ncNewCustomString& str);
    ncMetadataObj(ncNewCustomString&& str);
    
    ncMetadataObj(const ncMetadataObj& source);
    ncMetadataObj& operator = (const ncMetadataObj& source);
    
    ncMetadataObj(ncMetadataObj&& source);
    ncMetadataObj& operator = (ncMetadataObj&& source);

    void push_back(const ncNewCustomString& str);
    void push_back(ncNewCustomString&& str);
    
    //...略
    
private:
    ncOldCustomString           _oldCustomStr;
    ncNewCustomString           _newCustomStr;
};

//const左值引用拷贝构造函数
//指针成员变量深拷贝memcopy---线性时间复杂度
ncMetadataObj::ncMetadataObj(const ncMetadataObj& source)
{
    MK_PRINT_MSG("--(const ncMetadataObj& source)");
    
    _oldCustomStr = source._oldCustomStr;
    _newCustomStr = source._newCustomStr;
    
    //模拟指针对象深拷贝
    //申请内存
    //memcopy(...);
    usleep (LOSS_TIME);//模拟其他数据成员的memcopy
}

//右值引用拷贝构造函数
//指针成员变量浅拷贝----常量时间复杂度;
ncMetadataObj::ncMetadataObj(ncMetadataObj&& source)
{
    MK_PRINT_MSG("--(ncMetadataObj&& source)");
    
    _oldCustomStr = std::move(source._oldCustomStr);
    _newCustomStr = std::move(source._newCustomStr);
    
    //模拟指针对象浅拷贝
    //_p = p;
}
/*
源码路径:
ut_rvaluereference\usage\ncMetadataObj.h
*/
// ...略
```

### 例3 下层类
[下层类] : 下层类subClass实现所有接受右值引用参数的方法,供上层类在实现右值方法时调用;


```c++
//类实现者
class ncMetadataObj
{
public:
    ncMetadataObj(const ncOldCustomString& str);
    ncMetadataObj(ncOldCustomString&& str);
    
    ncMetadataObj(const ncNewCustomString& str);
    ncMetadataObj(ncNewCustomString&& str);
    
    ncMetadataObj(const ncMetadataObj& source);
    ncMetadataObj& operator = (const ncMetadataObj& source);
    
    ncMetadataObj(ncMetadataObj&& source);
    ncMetadataObj& operator = (ncMetadataObj&& source);

    void push_back(const ncNewCustomString& str);
    void push_back(ncNewCustomString&& str);
    
    //...略
    
private:
    ncOldCustomString           _oldCustomStr;
    ncNewCustomString           _newCustomStr;
};

//下层类1
class ncOldCustomString
{
public:
    ncOldCustomString(const ncOldCustomString& source);
    ncOldCustomString& operator = (const ncOldCustomString& source);
};

//下层类2
class ncNewCustomString
{
public:
    ncNewCustomString(const ncNewCustomString& source)
    ncNewCustomString& operator = (const ncNewCustomString& source)
    
    ncNewCustomString(ncNewCustomString&& source)
    ncNewCustomString& operator = (ncNewCustomString&& source)
};

```


##### [测试按值返回]: 
类自身实现了右值引用拷贝构造函数,才能提升按值返回的性能
```c++
ncOldCustomString GetOldString()
{
    ncOldCustomString str("some string");
    return str;
}
ncNewCustomString GetNewString()
{
    ncNewCustomString str("some string");
    return str;
}
TEST(ut_metadataObj, return_Value)
{
    {
        ncAutoProfilePoint point(usedSecond);
        GetOldString();
    }
    MK_PRINT_MSG("usedSecond = %.2f\n", usedSecond);
    
    {
        ncAutoProfilePoint point(usedSecond);
        GetNewString();
    }
    MK_PRINT_MSG("usedSecond = %.2f\n", usedSecond);
}
```

执行结果:
![这里写图片描述](https://img-blog.csdn.net/20180524181214982?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



##### [测试按值传参]:
类实现了按值传参函数, 本例中是类ncMetadataObj的构造函数,
是否能提升性能,还取决于参数类(下层类)是否对右值引用做了兼容;

```c++
TEST(ut_metadataObj, constructor)
{
    {
        ncAutoProfilePoint point(usedSecond);
        ncMetadataObj obj1(ncOldCustomString("some string..."));
        obj1.fun();
    }
    MK_PRINT_MSG("obj1 usedSecond = %.2f\n", usedSecond);
    
    {
        ncAutoProfilePoint point(usedSecond);
        ncMetadataObj obj2(ncNewCustomString("some string..."));
        obj2.fun();
    }
    MK_PRINT_MSG("obj2 usedSecond = %.2f", usedSecond);
}
```

执行结果:
![这里写图片描述](https://img-blog.csdn.net/20180524181229653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


