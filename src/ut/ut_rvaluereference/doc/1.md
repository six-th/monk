[toc]

# 1.为什么要了解右值引用?

    
### 例1:按值返回
判断以下2个函数在c++98和c++11中的性能表现:
```c++
void fun_vector1(vector<ncLargeStruct>& vStr)
{
    vStr.clear();
    for(int i = 0; i != loopCount; ++i) {
        vStr.push_back(ncLargeStruct());
    }
}

vector<ncLargeStruct> fun_vector2()
{
    vector<ncLargeStruct> vStr;
    for(int i = 0; i != loopCount; ++i) {
        vStr.push_back(ncLargeStruct());
    }
    return vStr;
}

TEST(ut_vector, vector)
{
    {
        ncAutoProfilePoint point(usedSecond);
        
        vector<ncLargeStruct> vStr;
        fun_vector1(vStr);
    }
    printf("fun_vector1() usedSecond = %.2fs\n", usedSecond);
    
    {
        ncAutoProfilePoint point(usedSecond);
        
        vector<ncLargeStruct> vStr2;
        vStr2 = fun_vector2();
    }
    
    printf("fun_vector2() usedSecond = %.2fs\n", usedSecond);
}
/*
源码路径:
ut_rvaluereference\before_after\ut_vector.cpp  
测试环境:
linux: 3.10.0-327.el7.x86_64 #1 
gcc:  4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) 
*/
```

C++98运行结果:
![这里写图片描述](https://img-blog.csdn.net/20180524113803271?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

C++11运行结果:
![这里写图片描述](https://img-blog.csdn.net/20180524113815715?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

数据分析:
![这里写图片描述](https://img-blog.csdn.net/20180524113827310?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


例1总结:
>代码风格对比:
>>fun_vector2更符合人类思维方式; 
>>如果用fun_vector1实现递归或嵌套调用,非常不友好; 

>性能横向对比: 
>>两个函数在c++11中性能均优于98中的表现; 

>性能纵向对比: 
>>c++98中,fun1性能优于fun2;
>>c++11中,两函数性能旗鼓相当;

>结论:
>>c++11中, "按值返回"风格的函数变为可接受了;

    
    
        
### 例2:按值传参
判断以下2个类的构造函数在c++98和c++11中的性能表现;

```c++
#ifndef __ENABLE_CXX11__
    #define move(data)   data
#endif

class normalObj1
{
public:
    normalObj1(const ncLargeStruct& data)
        : _data(data)
    {
    }
    void fun(){}
private:
    ncLargeStruct _data;
};

class normalObj2
{
public:
    normalObj2(ncLargeStruct data)
        : _data(move(data))
    {
    }
    void fun(){}
private:
    ncLargeStruct _data;
};


//测试用例 Construction1:
TEST(ut_normalObj, Construction1)
{
    {
        ncAutoProfilePoint point(usedSecond);
        for(int i = 0; i != loopCount; ++i) {
            ncLargeStruct str;
            normalObj1 obj(str);
            obj.fun();
        }
    }
    printf("normalObj1() usedSecond = %.2fs\n", usedSecond);
    
    
    {
        ncAutoProfilePoint point(usedSecond);
        for(int i = 0; i != loopCount; ++i) {
            ncLargeStruct str;
            normalObj2 obj(str);
            obj.fun();
        }
    }
    printf("normalObj2() usedSecond = %.2fs\n", usedSecond);
}

//测试用例 Construction2:
TEST(ut_normalObj, Construction2)
{
    {
        ncAutoProfilePoint point(usedSecond);
        for(int i = 0; i != loopCount; ++i) {
            ncLargeStruct str;
            normalObj1 obj(move(str));
            obj.fun();
        }
    }
    printf("normalObj1() usedSecond = %.2fs\n", usedSecond);
    
    {
        ncAutoProfilePoint point(usedSecond);
        for(int i = 0; i != loopCount; ++i) {
            ncLargeStruct str;
            normalObj2 obj(move(str));
            obj.fun();
        }
    }
    printf("normalObj2() usedSecond = %.2fs\n", usedSecond);
}

/*
源码路径:
ut_rvaluereference\before_after\ut_vector.cpp  
测试环境:
linux: 3.10.0-327.el7.x86_64 #1 
gcc:  4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) 
*/
```

C++98运行结果:
![这里写图片描述](https://img-blog.csdn.net/2018052417123863?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

C++11运行结果:
![这里写图片描述](https://img-blog.csdn.net/2018052417125253?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


数据分析:
![这里写图片描述](https://img-blog.csdn.net/20180524171301132?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1dPVzU0MjYyMTEyNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


例2总结:
>性能横向对比:
>>类obj1, 在c++11中性能与c++98中相同;
>>类obj2, 在c++11中性能大幅优于98中的表现;

>性能纵向对比:
>>c++98, obj1性能优于obj2;
>>c++11, constructon1中,两者性能相同;
>>c++11, constructon2中,obj2大幅度优于obj1;

>结论:
某些特殊场景下,使用右值引用会得到不可思议的性能提升;




### 摘要

右值引用至少有以下好处:

* 降低了”***以右值初始化对象或给对象赋值***”的性能损耗;
* 降低了”***按值传参***”的性能损耗;
* 降低了”***按值返回***”的性能损耗;
* 降低了”***对象存入容器***”的性能损耗;
* 解决了”***vector或其他容器的自增长***”的性能损耗;
* 降低了“***对象交换swap***”操作的性能损耗; 
* 使得***一些标准库功能成为可能*** (例如std::unique_ptr, std::function);
* 使得***std::unique_ptr<T>可以放入容器*** ;
* 实现了”***完美转发***”;
* 代码风格更灵活, 例如返回一个容器或者***返回一个巨大的对象***成为可能;
* 即使你的代码中并不直接使用右值引用，也可以通过标准库，间接从这一新特性中受益;
    
    
