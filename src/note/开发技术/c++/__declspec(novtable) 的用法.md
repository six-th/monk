

```cpp
__declspec(novtable) 在C++中接口中广泛应用. 
不容易看到它是因为在很多地方它都被定义成为了宏.
 比如说ATL活动模板库中的ATL_NO_VTABLE, 其实就是__declspec(novtable).
 
 __declspec(novtable) 就是让类不要有虚函数表以及对虚函数表的初始化代码, 这样可以节省运行时间和空间.
  但是这个类一定不允许生成实例, 因为没有虚函数表, 就无法对虚函数进行调用.
 
因此, __declspec(novtable)一般是应用于接口(其实就是包含纯虚函数的类),
 因为接口包含的都是纯虚函数, 不可能生成实例. 
 我们把 __declspec(novtable)应用到接口类中, 这些接口类就不用包含虚函数表和初始化虚函数表的代码了. 
 它的派生类会自己包含自己的虚函数表和初始化代码.




Mircrosoft c++中提供了__declspec(novtable)来修饰一个类，来表示该类没有虚函数表，也就是虚函数都是纯虚的。
减小SIZE 是因为虚表是需要内存空间的，在不需要虚表的情况下，把虚表去掉就可以减少SIZE了。




C++中的虚函数的实现一般是通过虚函数表来实现的，类的虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址。

纯虚函数：
在基类中不能对虚函数给出有意义的实现，而把它说明为纯虚函数，
它的实现留给该基类的派生类去做。这就是纯虚函数的作用，（这应该不难理解吧？）






V TA B L E（虚函数表）和VPTR（指向虚函数表的指针）
编译器到底做了什么实现的虚函数的晚绑定呢？
 编译器对每个包含虚函数的类创建一个表（称为V TA B L E）。
 在V TA B L E中，编译器放置特定类的虚函数地址。在每个带有虚函数的类中，编译器秘密地置一指针，称为v p o i n t e r（缩写为V P T R），
 指向这个对象的V TA B L E。通过基类指针做虚函数调用时（也就是做多态调用时），
 编译器静态地插入取得这个V P T R，并在V TA B L E表中查找函数地址的代码，这样就能调用正确的函数使晚捆绑发生。
 为每个类设置V TA B L E、初始化V P T R、为虚函数调用插入代码，所有这些都是自动发生的，所以我们不必担心这些。
 利用虚函数，这个对象的合适的函数就能被调用，哪怕在编译器还不知道这个对象的特定类型的情况下。（《C++编程思想》） 



```