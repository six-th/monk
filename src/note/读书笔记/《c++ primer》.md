基类和派生类中使用同名成员函数时--《c++ primer》
```cpp
    派生类重定义基类函数：
    基类和派生类中使用同名成员函数时；
    派生类作用域中派生类成员将屏蔽基类成员。即使函数原型不同，基类成员也会被屏蔽！
    class base
    {
    public:
         int fun();
    };
    class derived:public base
    {
    public:
         int fun(int);
    };

    derived D;
    d.fun();     //error:参数错误

    派生类重定义基类重载函数：
    由于派生类重定义基类重载函数时，会屏蔽掉基类的其他重载函数（假设该函数有多个重载），为了重定义不得不重定义每个基类重载版本，这令人厌烦；
    解决办法：15.5章节。使用using声明，可以访问基类中的名字；
    派生类不用重定义基类每个重载版本，它可以为基重载成员提供using声明，一个using声明只能指定一个名字，不能指定形参表，因此，为基类成员函数名称而作的using声明将该函数所有重载实例加到了派生类的作用域，派生类只需要重定义本类型确实必须重定义的那个函数即可；对其他版本可以使用继承的定义；

    class derived:public base
    {
    public:
         using base::fun;
         int fun(int);
    };

```
