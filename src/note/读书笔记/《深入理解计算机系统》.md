#第1章 计算机系统漫游
    位+上下文
    像hello.c这样由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件；

    编译系统（compilation system）
    预处理器、编译器、汇编器和链接器一起构成了编译系统；


    存储设备形成层次结构
    系统中的存储设备划分为层次结构：
    CPU寄存器在顶部，接着是多层的硬件高速缓存存储器，DRAM主存和磁盘存储器；


    虚拟存储器
    虚拟存储器是一个抽象概念，它为每个进程提供一个假象，即每个进程都独占使用主存；
    虚拟地址空间从下往上依次增加，依次为：
    程序代码和数据、堆、共享库、栈、内核虚拟存储器；

    计算机系统中的抽象
    操作系统内核是应用程序和硬件之间的媒介，它提供三个基本的抽象：
    文件是对I/O设备的抽象，
    虚拟存储器是对主存和磁盘的抽象，
    而进程是对处理器主存和I/O设备的抽象（一个正在运行的程序）；




#第2章 信息的表示和处理
```cpp
gcc -std=c99 hello.c
编译选项-ansi和-std=c89的用法是一样的，会根据ANSI或者ISO C90标准来编译程序；
C98有时也称为C89,因为它的标准化工作是从1989年开始的；
编译选项-std=c99会让编译器按照ISO C99的规则进行编译；

字长 word size
字长决定的最重要的参数就是虚拟地址空间的最长大小；
对于1个字长为w位的机器而言，虚拟地址的范围为0~ 2^w - 1，程序最多访问2^w个字节；

寻址
在几乎所有的机器上，多字节对象都被存储为连续的字节序列；对象的地址为所使用字节中最小的地址；
例如一个int变量a的地址为0x100，则a的4个字节将被存储在存储器的0x100，0x101，0x102，0x103的位置；

字节顺序
1、某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，最低有效字节在最前面的方式，称为小端法(littile endian);
大多数intel兼容机都采用这种规则；
2、另一些机器按照从最高有效字节到最低有效字节的顺序存储，最高有效字节在最前的方式，称为大端法(big endian);
大多数IBM和Sun Microsystems的机器都采用这种规则；
3、注意我们说的“大多数”这些规则并没有严格按照企业界限划分，比如IBM和Sun制造的个人计算机使用的是intel兼容的处理器，因此用的就是little-endian；
4、许多比较新的微处理器使用双端法（bi-endian），也就是说可以把他们配置成作为大端或者小端的机器运行；
5、实际上，little endian和big endian出自jonathan swift的《格列佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致；就像鸡蛋的问题一样，没有技术上的原因来选择字节顺序规则；
6、C语言中字符串被编码为一个以null字符结尾的字符数组，字符串存储时与字节顺序和字大小规则无关，因而，文本数据比二进制数据具有更强的平台独立性；

布尔代数简介
这起源于1850年前后乔治*布尔(Gerorge Boole 1815-1864)的工作；因此称为布尔代数；
位级运算符：
~就是NOT，取反
|就是OR 或
&就是AND 与
^就是EXCLUSIVE-OR 异或
逻辑运算符：
||、&&、！


不用临时变量交换两个数的值：
void inplace_swap(int* x, int* y)
{
     *y = *x ^ *y;
     *x = *x ^ *y;
     *y = *x ^ *y;
}
刘浩备注：这里存在个问题，如果x和y相等的话，就失效了。因此函数体内需要添加相等检测；


用位级和逻辑运算实现x==y;
只使用位级和逻辑运算，编写一个C表达式，等价于x==y;
答：这个表达式为 !(x^y);

移位运算：
1、移位运算是从左至右可结合的，所以x<<j<<k等价于(x<<j)<<k;
左移运算x<<k，表示x向左移动k位，丢弃最高的k位，并在右端补k个0；
有一个相应的右移运算x>>k，但是它的行为有点微妙，一般而言，机器支持两种形式的右移：逻辑右移和算数右移；
逻辑右移是在左端补k个0；
算数右移是在左端补k个最高有效位的值；
2、C语言标准并没有明确定义应该使用哪种类型的右移。
对于无符号数据（unsigned整型）右移必须是逻辑的；
对于有符号数据，算数的或者逻辑的右移都可以；
这就意味着任何假设一种或者另一种右移形式的代码都潜在着可移植问题；
然后，实际上，几乎所有的编译器/机器组合都对有符号数据使用算术右移；且许多程序员也都假设机器会使用这种右移；
简而言之：
逻辑左移=算术左移，右边统一添0；
逻辑右移，左边统一添0，算术右移，左边添加的数和符号有关；

移位运算操作符优先级：
常常有人写出这样的表达式：1<<2+3<<4，其本意是(1<<2) + (3<<4)，但在C语言中，前面的表达式等价于1<<(2+3)<<4;
这是由于加法（和减法）的优先级比移位运算符要高；

整型数据类型取值：

1、数据类型long long是在ISO C99中引入的，它需要至少8个字节表示；
2、C库中的文件<limits.h>定义了一组常量，来限定编译器运行的这台机器的不同整型数据类型的取值范围；
3、ISO C99标准文件stdint.h中引入了另一类数据类型；他们的声明形如intN_t和uintN_t，指定的是N位有符号和无符号整数，N的具体值与实现有关，但是大多数编译器允许的值为8、16、32、64；


补码编码：
将字的最高有效位解释为负权（negative weight），最高有效位也称为符号位；
符号位设置为1时，表示值为负，设置为0时，表示值为非负；

有符号数和无符号数之间的转换
1、当执行一个运算时，如果它的一个运算数是有符号的，而另一个是无符号的，那么C语言会隐式的将有符号参数强制转换为无符号数，并假设这2个数都是非负的，来执行这个运算；
2、有符号数到无符号数的隐式转换会导致错误或者漏洞的方式，避免这种错误的一种方法就是绝不使用无符号数。。。


整数乘除与编译器优化
1、在大多数机器上，整数乘法指令相当慢，需要10个或者更多的时钟周期，然后其他整数运算（例如加法、减法、位级运算和移位）只需要1个时钟周期；
因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法；
例如假如一个程序包含表达式x*14，利用等式14=2^3+2^2+2^1，编译器会将乘法重写为(x<<3)+(x<<2)+(x<<1)实现了将一个乘法替换为三个移位和两个加法；
更好的方法是，编译器还可以利用属性14=2^4-2^1，将乘法重写为(x<<4)-(x<<1)；这样只需要两个移位和一个减法；
2、在大多数机器上，整数除法要比整数乘法更慢，需要30个或者更多的时钟周期；
除以2的幂也可以用移位运算来实现，只不过我们用的是右移，而不是左移，无符号和补码分别使用逻辑移位和算数移位来达到目的；


C语言中的浮点数
所有的C语言版本提供了两种不同的浮点数据类型：float和double，在支持IEEE浮点格式的机器上，对应于单精度和双精度浮点；
较新版本的C语言，包括ISO C99，包含第三种浮点数据类型，long double；
对于许多机器和编译器而言，这种数据类型等价于double；
不过对于intel兼容机来说，GCC用80位扩展精度格式来实现这种数据类型，提供了比标志64位格式大得多的取值范围和精度；

```


#第3章 程序的机器级表示

```cpp
gcc -O1 -o p p1.c p2.c
编译选项-O，[-Olevel] 告诉编译器使用第一级优化；通常提高优化级别会使最终程序运行更快，但是编译时间可能会变长，用调试工具对代码进行调试会更困难；

gcc -O1 -S code.c
这会使gcc运行编译器，产生一个汇编文件code.s，但是不做其他进一步的工作；

gcc -O1 -c code.c
gcc会编译并汇编该代码，这就会产生目标代码文件code.o；它是二进制格式，无法直接查看；

objdump -d code.o
反汇编器，根据目标代码产生一种类似于汇编代码的格式；


ATT与Intel汇编代码格式
ATT根据AT&T命名的，AT&T是运营贝尔实验室多年的公司；
ATT格式的汇编代码是GCC、OBJDUMP和其他一些我们使用的工具的默认格式；
其他一些编程工具，包括Microsoft的工具，以及来自Intel的文档，其汇编代码都是Intel格式的；
使用以下命令，GCC可以产生sum函数的Intel格式代码；
gcc -O1 -S -masm=intel code.c


todo：
汇编代码看得头疼，暂时跳过这一章，以后来填坑；

```



#第4章 处理器体系结构

	ISA
	Instruction-Set Architecture 指令集体系结构
	一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构；


	todo:
	留坑；




第5章 优化程序性能

```
编写高效程序需要几类活动：
第一，我们必须选择一组合适的算法和数据结构；
第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码；
第三，针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和多处理器的某种组合上并行的计算；


程序优化
程序优化的第一步就是消除不必要的内容，让代码尽可能有效地执行它期望的工作；这包括消除不必要的函数调用，条件测试和存储器引用；
程序优化的第二步，利用处理器提供的指令级并行能力（instruction-level parallelism)能力，同时执行多条指令；

存储器别名使用（memory aliasing）
两个指针可能指向同一个存储器位置的情况，称为存储器别名使用；
在只执行安全的优化中，编译器必须假设不同的指针可能会指向存储器中的同一个位置；

表示程序性能
我们引入度量标准每元素的周期数（Cycles Per Element，CPE）作为一种表示程序性能并指导我们改进代码的方法；

时钟周期
处理器活动的顺序是由时钟控制的；时钟提供了某个频率的规律新号，通常用千兆赫兹GHz,即10亿周期每秒来表示；
4GHz的处理器，表示处理器时钟运行频率为4*10^9赫兹；
每个时钟周期的时间是时钟频率的倒数，通常用纳秒（nanosecond）或皮秒来表示；
1纳秒等于10^-9秒；1皮秒等于10^-12秒；

5.4消除循环的低效率
代码移动（code motion），这类优化包括识别要执行多次（例如在循环中）但是计算结果不会改变的计算；因而可以将计算移动到代码前面不会被多次求值得部分；

5.5减少过程调用：
对于性能至关重要的应用来说，为了速度，经常必须要损害一些模块性和抽象性；

5.6消除不必要的存储器引用
引入一个临时变量，它在循环中用来累计计算出来的值，只有在循环完成之后结果才存放在存储器中；

```




第6章 存储器层次结构
``
``





























