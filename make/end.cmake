MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "include end.cmake")

#依赖 mkheaders
INCLUDE_DIRECTORIES(${MK_PATH}/markcore/include;)

# 依赖 benchmark
IF(${NEED_BENCHMARK})
    include(${MK_PATH}/3rd_Party/benchmark/config.cmake)
ENDIF()

# 依赖 boost
IF(${NEED_BOOST_FULL})
	include(${MK_PATH}/3rd_Party/boost/config.cmake)
ENDIF()

# 依赖 brpc
IF(${NEED_BRPC})
    include(${MK_PATH}/3rd_Party/brpc/config.cmake)
ENDIF()

# 依赖 crc32c
IF(${NEED_CRC32C})
    include(${MK_PATH}/3rd_Party/crc32c/config.cmake)
ENDIF()

# 依赖 gflags
IF(${NEED_GFLAGS})
    include(${MK_PATH}/3rd_Party/gflags/config.cmake)
ENDIF()

# 依赖 gtest
IF(${NEED_GTEST})
    include(${MK_PATH}/3rd_Party/gtest/config.cmake)
ENDIF()

# 依赖 jemalloc
IF(${NEED_JEMALLOC})
    include(${MK_PATH}/3rd_Party/jemalloc/config.cmake)
ENDIF()

# 依赖 leveldb
IF(${NEED_LEVELDB})
    include(${MK_PATH}/3rd_Party/leveldb/config.cmake)
ENDIF()

# 依赖 libexpat
IF(${NEED_EXPAT})
    include(${MK_PATH}/3rd_Party/libexpat/config.cmake)
ENDIF()

# 依赖 libressl
IF(${NEED_RESSL})
    include(${MK_PATH}/3rd_Party/libressl/config.cmake)
ENDIF()

# 依赖 libuuid
IF(${NEED_UUID})
    include(${MK_PATH}/3rd_Party/libuuid/config.cmake)
ENDIF()

# 依赖 protobuf
IF(${NEED_PROTOBUF})
    include(${MK_PATH}/3rd_Party/protobuf/config.cmake)
ENDIF()

# 依赖 snappy
IF(${NEED_SNAPPY})
    include(${MK_PATH}/3rd_Party/snappy/config.cmake)
ENDIF()

# 依赖 thrift
IF(${NEED_THRIFT})
    include(${MK_PATH}/3rd_Party/thrift/config.cmake)
ENDIF()

# 依赖 zlib
IF(${NEED_ZLIB})
    include(${MK_PATH}/3rd_Party/zlib/config.cmake)
ENDIF()

# 依赖 zstd
IF(${NEED_ZSTD})
    include(${MK_PATH}/3rd_Party/zstd/config.cmake)
ENDIF()

# 依赖 makecore
IF(${NEED_MARKCORE})
    include(${MK_PATH}/markcore/config.cmake)
ENDIF()

# 设置所有的链接库
SET(LINK_ALL_LIBS   ${LINK_CUSTOM_LIBS})
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "SET LINK_ALL_LIBS = ${LINK_ALL_LIBS}")

# 获取当前目录及其子目录下的所有源文件
SET(SRC "")
FOREACH(subdir ${SOURCE_DIRS})
    IF(EXISTS ${subdir}/res)
        IF(NOT DEFINED RES_TARGET_NAME)
            SET(RES_TARGET_NAME "-")
        ENDIF()
        add_res_files_target(${subdir}/res ${LIBS_PATH} each_res_clean_files ${RES_TARGET_NAME})
    ENDIF()
    AUX_SOURCE_DIRECTORY(${subdir} subdir_src)
	MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET subdir_src = ${subdir_src}")
    SET(SRC ${SRC} ${subdir_src})
    SET(RES_CLEAN_FILES ${RES_CLEAN_FILES} ${each_res_clean_files})
    SET(subdir_src "")
    SET(each_res_clean_files "")
ENDFOREACH(subdir ${DIRS})
SET(SOURCESRCS ${SRC})
#MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "SET SOURCESRCS = ${SOURCESRCS}")


#编译额外指定的源文件 INCLUDE_SOURCE_FILES
SET(ALLSRCS ${SOURCESRCS} ${INCLUDE_SOURCE_FILES} ${MK_BUILD_SOURCE_FILES})

# 获取所有源文件,并统一处理成以绝对路径显示的文件名,以便进行文件过滤
SET(ALL_SOURCES "")
FOREACH(_allsrc ${ALLSRCS})
    get_filename_component(_allsrc_path ${_allsrc} PATH)
    get_filename_component(_allsrc_name ${_allsrc} NAME)
    # _allsrc_path为空表示当前路径
    IF("${_allsrc_path}" STREQUAL "")
        SET(ALL_SOURCES ${ALL_SOURCES} ${CMAKE_CURRENT_SOURCE_DIR}/${_allsrc})
    ELSEIF("${_allsrc_path}" STREQUAL ".")
        SET(ALL_SOURCES ${ALL_SOURCES} ${CMAKE_CURRENT_SOURCE_DIR}/${_allsrc_name})
    ELSEIF(IS_ABSOLUTE ${_allsrc_path})
        SET(ALL_SOURCES ${ALL_SOURCES} ${_allsrc})
    ELSE()
        SET(ALL_SOURCES ${ALL_SOURCES} ${CMAKE_CURRENT_SOURCE_DIR}/${_allsrc})
    ENDIF()
ENDFOREACH()
#MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "SET ALL_SOURCES = ${ALL_SOURCES}")



# 过滤不需要编译的文件，需要编译的文件放到变量OUTPUTS
MACRO(FILTER_OUT FILTERS INPUTS OUTPUTS)
   SET(FOUT "")
   FOREACH(INP ${INPUTS})
       SET(FILTERED 0)
       FOREACH(FILT ${FILTERS})
           IF(${FILTERED} EQUAL 0)
               IF("${FILT}" STREQUAL "${INP}")
                   SET(FILTERED 1)
               ENDIF("${FILT}" STREQUAL "${INP}")
           ENDIF(${FILTERED} EQUAL 0)
       ENDFOREACH(FILT ${FILTERS})
       IF(${FILTERED} EQUAL 0)
           SET(FOUT ${FOUT} ${INP})
       ENDIF(${FILTERED} EQUAL 0)
   ENDFOREACH(INP ${INPUTS})
   SET(${OUTPUTS} ${FOUT})
ENDMACRO(FILTER_OUT FILTERS INPUTS OUTPUTS)
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "MACRO(FILTER_OUT FILTERS INPUTS OUTPUTS)")


IF("${EXCLUDE_SOURCE_FILES}" STREQUAL "")
    SET(OUTPUTS ${ALL_SOURCES}
                ${THRIFT_GEN_CPP_HDRS}
                ${THRIFT_GEN_CPP_SRCS}
                ${IDL_HEADER_FILES})
ELSE()
    SET(ALL_EXCLUDE_SOURCE_FILES "")
    FOREACH(_exclude_source_file ${EXCLUDE_SOURCE_FILES})
        get_filename_component(_exclude_source_file_path ${_exclude_source_file} PATH)
        get_filename_component(_exclude_source_file_name ${_exclude_source_file} NAME)
        # 为空表示当前路径
        IF("${_exclude_source_file_path}" STREQUAL "")
            SET(ALL_EXCLUDE_SOURCE_FILES ${ALL_EXCLUDE_SOURCE_FILES} ${CMAKE_CURRENT_SOURCE_DIR}/${_exclude_source_file})
        ELSEIF("${_exclude_source_file_path}" STREQUAL ".")
            set(ALL_EXCLUDE_SOURCE_FILES ${ALL_EXCLUDE_SOURCE_FILES} ${CMAKE_CURRENT_SOURCE_DIR}/${_exclude_source_file_name})
        ELSEIF(IS_ABSOLUTE ${_exclude_source_file_path})
            SET(ALL_EXCLUDE_SOURCE_FILES ${ALL_EXCLUDE_SOURCE_FILES} ${_exclude_source_file})
        ELSE()
            SET(ALL_EXCLUDE_SOURCE_FILES ${ALL_EXCLUDE_SOURCE_FILES} ${CMAKE_CURRENT_SOURCE_DIR}/${_exclude_source_file})
        ENDIF()
    ENDFOREACH()
    # 过滤不需要编译的文件，需要编译的文件放到变量OUTPUTS
    FILTER_OUT("${ALL_EXCLUDE_SOURCE_FILES}" "${ALL_SOURCES}" OUTPUTS)
    SET(OUTPUTS ${OUTPUTS}
                ${THRIFT_GEN_CPP_HDRS}
                ${THRIFT_GEN_CPP_SRCS}
                ${IDL_HEADER_FILES})
ENDIF()

MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "SET ALL_EXCLUDE_SOURCE_FILES = ${ALL_EXCLUDE_SOURCE_FILES}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "SET OUTPUTS = ${OUTPUTS}")


#  链接
# 设置所有生成库和可执行文件的路径，在此统一所有输出路径。
# 设置不同的生成目标路径(解决MSVC会自动创建Debug和Release目录)

# First for the generic no-config case (e.g. with mingw)
SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${LIBS_PATH})
SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LIBS_PATH})
SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LIBS_PATH})

# Second, for multi-config builds (e.g. msvc)
FOREACH(OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})
	MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET OUTPUTCONFIG = ${OUTPUTCONFIG}")
    string(TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG)
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${LIBS_PATH})
    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${LIBS_PATH})
    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${LIBS_PATH})
ENDFOREACH(OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES)


# link类型
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET TARGET_TYPE = ${TARGET_TYPE}")

#如果是RUNTIME，则生成可执行文件
IF("${TARGET_TYPE}" STREQUAL "RUNTIME")
	# win32 windows程序需要加上WIN32选项
	IF(WIN32)
		IF("${SUBSYSTEM}" STREQUAL "WINDOWS")
			SET(EXPECT_LINK_FLAG WIN32)
			MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "SET EXPECT_LINK_FLAG = ${EXPECT_LINK_FLAG}")
		ENDIF()
		IF(NOT MSVC_VERSION)
			SET(CUSTOM_LDFLAGS "${CUSTOM_LDFLAGS} /MANIFESTUAC:\"level='requireAdministrator' uiAccess='false'\"")
			MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "SET CUSTOM_LDFLAGS = ${CUSTOM_LDFLAGS}")
		ENDIF()
	ENDIF()
	
	#如果是RUNTIME,则生成可执行文件
	LINK_DIRECTORIES(${LIBS_PATH})
	ADD_EXECUTABLE(${TARGET_NAME} ${EXPECT_LINK_FLAG} ${OUTPUTS})
	TARGET_LINK_LIBRARIES(${TARGET_NAME} ${LINK_ALL_LIBS})
    target_compile_definitions(${TARGET_NAME} PUBLIC ${MK_DEFINITIONS_PUBLIC})
    target_compile_definitions(${TARGET_NAME} PRIVATE ${MK_DEFINITIONS_PRIVATE})
	MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "TARGET_LINK_LIBRARIES(${TARGET_NAME} ${LINK_ALL_LIBS})")
	
	#RUNTIME
	install_target(RUNTIME ${TARGET_NAME} .)
	
	#debuginfo
	MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET NEED_DEBUGINFO = ${NEED_DEBUGINFO}")
	IF(NEED_DEBUGINFO)
		SET(TARGET_FULL_NAME ${TARGET_NAME})
		ADD_CUSTOM_COMMAND(TARGET ${TARGET_NAME}
						   COMMAND objcopy --only-keep-debug ${TARGET_FULL_NAME} ${TARGET_FULL_NAME}.debug
						   COMMAND objcopy --strip-debug ${TARGET_FULL_NAME}
						   COMMAND objcopy --add-gnu-debuglink=${TARGET_FULL_NAME}.debug ${TARGET_FULL_NAME}
						   WORKING_DIRECTORY ${LIBS_PATH})
		LIST(APPEND DEBUGINFO_CLEAN_FILES ${LIBS_PATH}/${TARGET_FULL_NAME}.debug)
		install_files(debuginfo ${LIBS_PATH}/${TARGET_FULL_NAME}.debug)
	ENDIF()
    
# 链接成一个动态库
ELSEIF("${TARGET_TYPE}" STREQUAL "LIBRARY")
	LINK_DIRECTORIES(${LIBS_PATH})
	ADD_LIBRARY(${TARGET_NAME} SHARED ${OUTPUTS})
	TARGET_LINK_LIBRARIES(${TARGET_NAME} ${LINK_ALL_LIBS})
    target_compile_definitions(${TARGET_NAME} PUBLIC ${MK_DEFINITIONS_PUBLIC})
    target_compile_definitions(${TARGET_NAME} PRIVATE ${MK_DEFINITIONS_PRIVATE})
	MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "TARGET_LINK_LIBRARIES(${TARGET_NAME} ${LINK_ALL_LIBS})")
	
	#LIBRARY
	IF(WIN32)
		# Windows下的动态库被认为是RUNTIME类型
		install_target(RUNTIME ${TARGET_NAME} .)
		install_target(ARCHIVE ${TARGET_NAME} .)
	ELSE()
		install_target(LIBRARY ${TARGET_NAME} .)
	ENDIF()

	#debuginfo
	MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET NEED_DEBUGINFO = ${NEED_DEBUGINFO}")
	IF(NEED_DEBUGINFO)
		SET(TARGET_FULL_NAME ${CMAKE_SHARED_LIBRARY_PREFIX}${TARGET_NAME}${CMAKE_SHARED_LIBRARY_SUFFIX})
		ADD_CUSTOM_COMMAND(TARGET ${TARGET_NAME}
						   COMMAND objcopy --only-keep-debug ${TARGET_FULL_NAME} ${TARGET_FULL_NAME}.debug
						   COMMAND objcopy --strip-debug ${TARGET_FULL_NAME}
						   COMMAND objcopy --add-gnu-debuglink=${TARGET_FULL_NAME}.debug ${TARGET_FULL_NAME}
						   WORKING_DIRECTORY ${LIBS_PATH})
		LIST(APPEND DEBUGINFO_CLEAN_FILES ${LIBS_PATH}/${TARGET_FULL_NAME}.debug)
		install_files(debuginfo ${LIBS_PATH}/${TARGET_FULL_NAME}.debug)
	ENDIF()
	
# 链接成一个静态库
ELSEIF("${TARGET_TYPE}" STREQUAL "ARCHIVE")
	LINK_DIRECTORIES(${LIBS_PATH})
	ADD_LIBRARY(${TARGET_NAME} STATIC ${OUTPUTS})
	TARGET_LINK_LIBRARIES(${TARGET_NAME} ${LINK_ALL_LIBS})
    target_compile_definitions(${TARGET_NAME} PUBLIC ${MK_DEFINITIONS_PUBLIC})
    target_compile_definitions(${TARGET_NAME} PRIVATE ${MK_DEFINITIONS_PRIVATE})
	MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "TARGET_LINK_LIBRARIES(${TARGET_NAME} ${LINK_ALL_LIBS})")
	install_target(ARCHIVE ${TARGET_NAME} .)
ELSEIF("${TARGET_TYPE}" STREQUAL "")
	#如果没有指定，报错
	MESSAGE(FATAL_ERROR "Must have a target type")
ENDIF()



# 是否设置RES_FILES
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET RES_FILES = ${RES_FILES}")
IF(NOT "${RES_FILES}" STREQUAL "")
	ADD_CUSTOM_TARGET(${TARGET_NAME}_res ALL DEPENDS ${RES_FILES})
	ADD_DEPENDENCIES(${TARGET_NAME} ${TARGET_NAME}_res)
	MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "ADD_DEPENDENCIES(${TARGET_NAME})")
	MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "ADD_DEPENDENCIES(${TARGET_NAME}_res)")
ENDIF()


# 是否设置target版本
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET TARGET_VERSION = ${TARGET_VERSION}")
IF(NOT "${TARGET_VERSION}" STREQUAL "")
	SET_TARGET_PROPERTIES(${TARGET_NAME} PROPERTIES VERSION ${TARGET_VERSION})
ENDIF()


# 自定义链接参数  
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CUSTOM_LDFLAGS = ${CUSTOM_LDFLAGS}")
IF (DEFINED CUSTOM_LDFLAGS) 
	SET_TARGET_PROPERTIES(${TARGET_NAME} PROPERTIES LINK_FLAGS ${CUSTOM_LDFLAGS}) 
ENDIF ()



# 添加编译IDL文件后的文件、mo文件和到clean选项，以便clean命令清除
SET(ADDITIONAL_CLEAN_FILES ${RES_CLEAN_FILES}; ${IDL_CLEAN_FILES}; ${THRIFT_CLEAN_FILES}; ${DEBUGINFO_CLEAN_FILES})
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "SET ADDITIONAL_CLEAN_FILES = ${ADDITIONAL_CLEAN_FILES}")
SET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${ADDITIONAL_CLEAN_FILES}")


MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_SYSTEM_NAME = ${CMAKE_SYSTEM_NAME}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_SYSTEM = ${CMAKE_SYSTEM}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_SYSTEM_VERSION = ${CMAKE_SYSTEM_VERSION}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_SYSTEM_PROCESSOR = ${CMAKE_SYSTEM_PROCESSOR}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET PROJECT_NAME = ${PROJECT_NAME}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_BUILD_TYPE = ${CMAKE_BUILD_TYPE}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET TARGET_TYPE = ${TARGET_TYPE}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_BUILD_VERSION = ${CMAKE_BUILD_VERSION}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET PROJECT_BINARY_DIR = ${PROJECT_BINARY_DIR}")

MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_CXX_FLAGS_DEBUG = ${CMAKE_CXX_FLAGS_DEBUG}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_CXX_FLAGS_RELEASE = ${CMAKE_CXX_FLAGS_RELEASE}")

MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_EXE_LINKER_FLAGS = ${CMAKE_EXE_LINKER_FLAGS}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_EXE_LINKER_FLAGS_RELEASE = ${CMAKE_EXE_LINKER_FLAGS_RELEASE}")

MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_CXX_FLAGS = ${CMAKE_CXX_FLAGS}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_SHARED_LINKER_FLAGS = ${CMAKE_SHARED_LINKER_FLAGS}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_SHARED_LINKER_FLAGS_RELEASE = ${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "GET CMAKE_STATIC_LINKER_FLAGS = ${CMAKE_STATIC_LINKER_FLAGS}")

MESSAGE([${CMAKE_CURRENT_LIST_FILE}:${CMAKE_CURRENT_LIST_LINE}]: "\n**end.cmake end-------------------------------------------------------------------")



