


```cpp
#define __T(x) L##x

这是相当模糊的语法，但它在ANSI C标准的C预处理器中，那一对数字符号被称为“令牌”粘贴。
它使得字母L和宏参数拼接在一起。因此如果宏参数是"hello"那么L##x就是L"hello"


在宏定义中经常会用到#和##
单井号(#)
把传递过来的参数当成字符串进行替代
如下示例：
 程序代码
#define display(name) printf(""#name"")
int main() {
display(name);
}


输出：
name


双井号(##)
称为连接符
在带参数的宏定义中将两个子串(token)联接起来，从而形成一个新的子串。但它不可以是第一个或者最后一个子串。所谓的子串(token)就是指编译器能够识别的最小语法单元。具体的定义在参考编译原理。


下面是MSDN上的一个例子。
假设程序中已经定义了这样一个带参数的宏：
 程序代码
#define paster( n ) printf( "token" #n " = %d", token##n )
//同时又定义了一个整形变量：
int token9 = 9;


现在在主程序中以下面的方式调用这个宏：
paster( 9 );


那么在编译时，上面的这句话被扩展为：
printf( "token" "9" " = %d", token9 );


注意到在这个例子中，paster(9);中的这个”9”被原封不动的当成了一个字符串，与”token”连接在了一起，从而成为了token9。而#n也被”9”所替代。


可想而知，上面程序运行的结果就是在屏幕上打印出token9=9

```